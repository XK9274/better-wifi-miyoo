#autoload

[[ _matcher_num -gt 1 || $_lastcomp[nmatches] -eq 0 ]] && return 1

local list

zstyle -s ":completion:${curcontext}:" old-list list

# If this is a listing widget and there is already an old list,
# and either the style :oldlist:old-list is `always', or it is not `never'
# and the list is not already shown, then use the existing list for listing
# (even if it was generated by another widget).
# Do this also if there is an old list and it was generated by the
# completer named by the oldlist_list key.

if [[ -n $compstate[old_list] && $list != never &&
      $LASTWIDGET != _complete_help && $WIDGET != _complete_help ]]; then
  if [[ $WIDGETSTYLE = *list* && ( $list = always || $list != shown ) ]]; then
    compstate[old_list]=keep
    return 0
  elif [[ $list = *${_lastcomp[completer]}* ]]; then
    [[ "$_lastcomp[insert]" = unambig* ]] && compstate[to_end]=single
    compstate[old_list]=keep
    if [[ -o automenu ]]; then
      compstate[insert]=menu
    else
      compadd -Qs "$SUFFIX" - "$PREFIX"
    fi
    return 0
  fi
fi

# If this is a completion widget, and we have a completion inserted already,
# and the style :oldlist:old-menu is `true', then we cycle through the
# existing list (even if it was generated by another widget).

if [[ -z $compstate[old_insert] && -n $compstate[old_list] &&
      ( $_lastcomp[nmatches] -ne 0 || $WIDGET != $LASTWIDGET ) &&
      $LASTWIDGET != _complete_help && $WIDGET != _complete_help ]]; then
  compstate[old_list]=keep
  return 0
elif [[ $WIDGETSTYLE = *complete(|-prefix|-word) ]] &&
     zstyle -T ":completion:${curcontext}:" old-menu; then
  if [[ -n $compstate[old_insert] ]]; then
    compstate[old_list]=keep
    if [[ $WIDGETSTYLE = *reverse* ]]; then
      compstate[insert]=$(( compstate[old_insert] - 1 ))
    else
      compstate[insert]=$(( compstate[old_insert] + 1 ))
    fi
  else
    return 1
  fi
  return 0
fi

return 1
